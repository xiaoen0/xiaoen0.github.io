<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>VSCode下进行Markdown环境搭建</title>
    <url>/posts/54b0646e.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  &emsp;集众程序猿所爱的VSCode写起Markdown文档来，风格很酷盖~</p>
<a id="more"></a>
<h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><h3 id="下载VSCode并安装"><a href="#下载VSCode并安装" class="headerlink" title="下载VSCode并安装"></a>下载VSCode并安装</h3><p><a href="https://code.visualstudio.com/">下载VSCode</a>，傻瓜式安装。</p>
<h3 id="VSCode里安装插件"><a href="#VSCode里安装插件" class="headerlink" title="VSCode里安装插件"></a>VSCode里安装插件</h3><p>&emsp;在此安装的插件:  </p>
<ul>
<li><u>Markdown All in One</u>:&ensp;Markdown语言支持。 </li>
<li><u>markdownlint</u>:&ensp;Markdown写作规范。</li>
<li><u>Prettier</u>:&ensp;格式错误自动修复。</li>
<li><u>Markdown Preview Enhanced</u>:&ensp;将原生Markdown预览的黑色背景改成白色。</li>
<li><u>Markdown Preview Github Styling</u>:&ensp;Github风格的预览。</li>
<li><u>Paste Image</u>:&ensp;从剪切板里粘贴图片到Markdown里。快捷键为Ctrl+Alt+V。</li>
<li><u>Markdown PDF</u>:&ensp;以PDF或图片的形式导出Markdown。</li>
</ul>
<h2 id="一些细节展示"><a href="#一些细节展示" class="headerlink" title="一些细节展示"></a>一些细节展示</h2><h3 id="Paste-Image的配置"><a href="#Paste-Image的配置" class="headerlink" title="Paste Image的配置"></a>Paste Image的配置</h3><p><img src="/images/image-20210131205254830.png" alt="image-20210131205254830"></p>
<p><img src="/images/image-20210131205352781.png" alt="image-20210131205352781"></p>
<p><img src="/images/image-20210131205421973.png" alt="image-20210131205421973"></p>
<p><img src="/images/image-20210131205452179.png" alt="image-20210131205452179"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>&emsp;如果追求风格酷盖，VSCode写Markdown是个不错的选择；如果追求简单快捷，还是Typora优秀。</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>环境</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo:NexT主题个性化配置</title>
    <url>/posts/1493449015.html</url>
    <content><![CDATA[<h3 id="背景使用彩带渲染"><a href="#背景使用彩带渲染" class="headerlink" title="背景使用彩带渲染"></a>背景使用彩带渲染</h3><!--<mark style = "background-color:#CDCDC1">主题配置文件</mark>-->
<p>在主题配置文件中，进行如下修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Canvas-ribbon</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-canvas-ribbon</span></span><br><span class="line"><span class="comment"># size: The width of the ribbon.</span></span><br><span class="line"><span class="comment"># alpha: The transparency of the ribbon.</span></span><br><span class="line"><span class="comment"># zIndex: The display level of the ribbon.</span></span><br><span class="line">canvas_ribbon:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">vendors:</span><br><span class="line">  <span class="comment"># Internal version: 1.0.0</span></span><br><span class="line">  <span class="comment"># See: https://github.com/zproo/canvas-ribbon</span></span><br><span class="line">  <span class="comment"># Example:</span></span><br><span class="line">  canvas_ribbon: //cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="链接持久化"><a href="#链接持久化" class="headerlink" title="链接持久化"></a>链接持久化</h3><p>Hexo默认的链接是http: //xxx(yourDomainName)/year/month/day/title 这种类型的。<br>这种默认的链接存在很多潜在的问题，比如：</p>
<ul>
<li>文章的title一般为中文，带有中文的url不利于SEO（搜索引擎优化）</li>
<li>如果对文章的title进行了修改，会导致链接发生变化，不利于文章的推广</li>
</ul>
<p>基于默认链接存在的潜在问题，我们最好把标题转成唯一的英文或数字字符串。配置如下：</p>
<p>1、安装插件hexo-abbrlink</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>
<p>2、在站点配置文件中添加abbrlink，并修改permalink</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">permalink: posts/:abbrlink/</span><br><span class="line"></span><br><span class="line"><span class="comment"># abbrlink config</span></span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32  <span class="comment">#support crc16(default) and crc32</span></span><br><span class="line">  rep: dec    <span class="comment">#support dec(default) and hex</span></span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>alg：算法。有crc16和crc32两种。</li>
<li>rep：进制。有dec(十进制)和hex(十六进制)两种。</li>
</ul>
<p>注：<br>crc16算法下的十进制编码最大为65535，这对个人博客来说已足够用。</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>环境</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo:在Typora中插图片的正确打开方式</title>
    <url>/posts/5e01ee03.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    在Typora中插入图片的方式非常简单，只需指定好路径就ok了~</p>
<a id="more"></a>

<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="建存储图片的文件夹"><a href="#建存储图片的文件夹" class="headerlink" title="建存储图片的文件夹"></a>建存储图片的文件夹</h3><p>​    在Hexo站点中的source目录下，建一个存储图片的文件夹，命名为images</p>
<h3 id="配置根目录"><a href="#配置根目录" class="headerlink" title="配置根目录"></a>配置根目录</h3><p>​    在待插图片的md文档头部的配置项中，添加 typora-root-url: ../</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo:在Typora中插图片的正确打开方式</span><br><span class="line">tags:</span><br><span class="line">	- Hexo</span><br><span class="line">	- Typora</span><br><span class="line">categories:</span><br><span class="line">	-- 计算机</span><br><span class="line">	 - 环境</span><br><span class="line">date: 2021-01-31 21:15:10</span><br><span class="line">typora-root-url: ../</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>配置后，根目录为md文档所在目录的上一级目录，即source目录。</p>
<h3 id="拖入图片并修改图片的url"><a href="#拖入图片并修改图片的url" class="headerlink" title="拖入图片并修改图片的url"></a>拖入图片并修改图片的url</h3><p>​    拖入图片，默认的url是本地的绝对路径。这时，点击图片右键 ——&gt; “复制图片到…”，选择source/images文件即可。</p>
<p>​    图片的url会随之变成相应的相对路径。</p>
<p>​    插入图片成功~</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>​    md文档中插入的图片能在Hexo站点中指定的路径中找到，当部署到github上时，博客中的图片自然也能正常被引用和显示。</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>环境</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>09(简单)：用两个栈实现队列</title>
    <url>/posts/c19aac04.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>09：<a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof">用两个栈实现队列</a></p>
<blockquote>
<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
</blockquote>
<p>示例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;CQueue&quot;</span>,<span class="string">&quot;appendTail&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>]</span><br><span class="line">[[],[<span class="number">3</span>],[],[]]</span><br><span class="line">输出：[<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">3</span>,-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;CQueue&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>,<span class="string">&quot;appendTail&quot;</span>,<span class="string">&quot;appendTail&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>]</span><br><span class="line">[[],[],[<span class="number">5</span>],[<span class="number">2</span>],[],[]]</span><br><span class="line">输出：[<span class="keyword">null</span>,-<span class="number">1</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="方案1：暴力破解"><a href="#方案1：暴力破解" class="headerlink" title="方案1：暴力破解"></a>方案1：暴力破解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明两个栈</span></span><br><span class="line">	<span class="keyword">private</span> Stack&lt;Integer&gt; stack1;</span><br><span class="line">	<span class="keyword">private</span> Stack&lt;Integer&gt; stack2;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//实例化栈</span></span><br><span class="line">    	stack1 = <span class="keyword">new</span> Stack&lt;&gt;();	<span class="comment">//用于入队</span></span><br><span class="line">    	stack2 = <span class="keyword">new</span> Stack&lt;&gt;();	<span class="comment">//用于出队</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">while</span>(!stack2.isEmpty()) &#123;<span class="comment">//当栈2不空时，元素搬回栈1，直到搬完</span></span><br><span class="line">    		stack1.push(stack2.pop());</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	stack1.push(value);	<span class="comment">//栈2为空，元素入队</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">while</span>(!stack1.isEmpty()) &#123;<span class="comment">//当栈1不空，元素搬入栈2，直到搬完</span></span><br><span class="line">    		stack2.push(stack1.pop());</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">if</span>(stack2.isEmpty()) &#123;<span class="comment">//无元素可出队</span></span><br><span class="line">    		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">return</span> stack2.pop();	<span class="comment">//有元素可出队</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方案2：算法优化"><a href="#方案2：算法优化" class="headerlink" title="方案2：算法优化"></a>方案2：算法优化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明两个栈</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack1;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//实例化栈</span></span><br><span class="line">    	stack1 = <span class="keyword">new</span> Stack&lt;&gt;();	<span class="comment">//用于入队</span></span><br><span class="line">    	stack2 = <span class="keyword">new</span> Stack&lt;&gt;();	<span class="comment">//用于出队</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    	</span><br><span class="line">    	stack1.push(value);	<span class="comment">//元素直接入队即可</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(stack2.isEmpty()) &#123;<span class="comment">//栈2为空，从栈1中搬入元素，直到搬完</span></span><br><span class="line">    		<span class="keyword">while</span>(!stack1.isEmpty()) &#123;</span><br><span class="line">    			stack2.push(stack1.pop());</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">if</span>(stack2.isEmpty()) &#123;<span class="comment">//栈1中元素搬完之后，栈2还为空，则无元素可出队</span></span><br><span class="line">    		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    	&#125;<span class="keyword">else</span> &#123;<span class="comment">//栈1中元素办完之后，栈2不空了，则元素直接出队</span></span><br><span class="line">    		<span class="keyword">return</span> stack2.pop();</span><br><span class="line">    	&#125;  	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h2><h3 id="java中创建栈"><a href="#java中创建栈" class="headerlink" title="java中创建栈"></a>java中创建栈</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h3 id="两个算法的时间复杂度"><a href="#两个算法的时间复杂度" class="headerlink" title="两个算法的时间复杂度"></a>两个算法的时间复杂度</h3><blockquote>
<p>方案1:</p>
<p>入队时间复杂度为O(n)</p>
<p>出队时间复杂度为O(n)</p>
</blockquote>
<blockquote>
<p>方案2:</p>
<p>入队时间复杂度为O(1)</p>
<p>出队时间复杂度为O(n)</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机</category>
        <category>《剑指offer》（第2版）</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》（第2版）</tag>
        <tag>栈</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>30(简单)：包含min函数的栈</title>
    <url>/posts/1eaa0f0b.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>30：<a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">包含min函数的栈</a></p>
<blockquote>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数。在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
</blockquote>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MinStack minStack = <span class="keyword">new</span> MinStack();</span><br><span class="line">minStack.push(-<span class="number">2</span>);</span><br><span class="line">minStack.push(<span class="number">0</span>);</span><br><span class="line">minStack.push(-<span class="number">3</span>);</span><br><span class="line">minStack.min();   --&gt; 返回 -<span class="number">3.</span></span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 <span class="number">0.</span></span><br><span class="line">minStack.min();   --&gt; 返回 -<span class="number">2.</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="方案1：使用两个栈"><a href="#方案1：使用两个栈" class="headerlink" title="方案1：使用两个栈"></a>方案1：使用两个栈</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">	<span class="comment">//声明两个栈</span></span><br><span class="line">	<span class="keyword">private</span> Stack&lt;Integer&gt; stack1,stack2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//实例化栈</span></span><br><span class="line">    	stack1 = <span class="keyword">new</span> Stack&lt;&gt;();	</span><br><span class="line">    	stack2 = <span class="keyword">new</span> Stack&lt;&gt;();	<span class="comment">//辅助栈，栈顶元素是栈1的最小值</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    	stack1.push(x);</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">if</span>(stack2.isEmpty() || x&lt;=stack2.peek()) &#123;</span><br><span class="line">    		stack2.push(x);</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(stack1.peek().equals(stack2.peek())) &#123;</span><br><span class="line">    		stack1.pop();</span><br><span class="line">    		stack2.pop();</span><br><span class="line">    	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    		stack1.pop();</span><br><span class="line">    	&#125; 	</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">return</span> stack1.peek();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//栈中最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">return</span> stack2.peek();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(stack1.pop().equals(stack2.peek())) &#123;</span><br><span class="line">    		stack2.pop();</span><br><span class="line">    	&#125;	</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h2 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h2><h3 id="Stack类的peek-方法"><a href="#Stack类的peek-方法" class="headerlink" title="Stack类的peek()方法"></a>Stack类的peek()方法</h3><blockquote>
<p>返回栈的栈顶元素。</p>
</blockquote>
<h3 id="Integer类型的-和equals"><a href="#Integer类型的-和equals" class="headerlink" title="Integer类型的==和equals()"></a>Integer类型的==和equals()</h3><p>《阿里Java开发手册》中有这样一项强制要求：</p>
<blockquote>
<p>“所有整形包装类对象之间值的比较，全部使用equals方法比较。说明：对于Integer var= ？在-128到127范围内的赋值，Integer对象在IntegerCache.cache产生，会复用已有对象，这个区间的Integer值可以直接使用==进行判断，但是这个区间之外的所有数据都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。”</p>
</blockquote>
<p>所以：</p>
<blockquote>
<p>两个Integer类型数据相等，直接用equals()即可。</p>
</blockquote>
<p>方案1的代码中，如果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(stack1.peek().equals(stack2.peek()))</span><br><span class="line">    写成</span><br><span class="line"><span class="keyword">if</span>(stack1.peek()==stack1.peek())</span><br></pre></td></tr></table></figure>
<p>那么，程序是无法通过的。</p>
<h3 id="java-lang-NullPointerException错误"><a href="#java-lang-NullPointerException错误" class="headerlink" title="java.lang.NullPointerException错误"></a>java.lang.NullPointerException错误</h3><p>错误提示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.NullPointerException</span><br></pre></td></tr></table></figure>
<p>原因：</p>
<blockquote>
<p>对象未实例化，就直接使用。</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机</category>
        <category>《剑指offer》（第2版）</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》（第2版）</tag>
        <tag>栈</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>59-Ⅱ(中等)：队列的最大值</title>
    <url>/posts/5c46b517.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>59-Ⅱ：<a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/">队列的最大值</a></p>
<blockquote>
<p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p>
<p>若队列为空，pop_front 和 max_value 需要返回 -1</p>
</blockquote>
<p>示例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[<span class="string">&quot;MaxQueue&quot;</span>,<span class="string">&quot;push_back&quot;</span>,<span class="string">&quot;push_back&quot;</span>,<span class="string">&quot;max_value&quot;</span>,<span class="string">&quot;pop_front&quot;</span>,<span class="string">&quot;max_value&quot;</span>]</span><br><span class="line">[[],[<span class="number">1</span>],[<span class="number">2</span>],[],[],[]]</span><br><span class="line">输出: [<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[<span class="string">&quot;MaxQueue&quot;</span>,<span class="string">&quot;pop_front&quot;</span>,<span class="string">&quot;max_value&quot;</span>]</span><br><span class="line">[[],[],[]]</span><br><span class="line">输出: [<span class="keyword">null</span>,-<span class="number">1</span>,-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>采用两个队列实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//声明一个普通队列</span></span><br><span class="line">	Queue&lt;Integer&gt; que;</span><br><span class="line">	<span class="comment">//声明一个双端单调队列</span></span><br><span class="line">	Deque&lt;Integer&gt; deq;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//构造方法，类的初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	</span><br><span class="line"> 	    <span class="comment">//实例化队列</span></span><br><span class="line">    	que= <span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">//普通队列，执行正常操作</span></span><br><span class="line">    	deq= <span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">//双端单调队列，辅助普通队列找最大值</span></span><br><span class="line">    	</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找队列中的最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">if</span>(deq.isEmpty()) &#123;</span><br><span class="line">    		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">return</span> deq.peekFirst();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//入队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    	</span><br><span class="line">    	que.offer(value);</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">while</span>(!deq.isEmpty() &amp;&amp; deq.peekLast()&lt;value) &#123;</span><br><span class="line">    		deq.pollLast();</span><br><span class="line">    	&#125;</span><br><span class="line">    	deq.offerLast(value);</span><br><span class="line">    	</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(que.isEmpty()) &#123;</span><br><span class="line">    		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">if</span>(que.peek().equals(deq.peekFirst())) &#123;</span><br><span class="line">    		deq.pollFirst();</span><br><span class="line">    	&#125;	</span><br><span class="line">    		</span><br><span class="line">    	<span class="keyword">return</span> que.poll();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h2><h3 id="java类Queue"><a href="#java类Queue" class="headerlink" title="java类Queue"></a>java类Queue</h3><p>1、创建一个普通队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Integer&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>2、常用方法</p>
<p>（1）isEmpty()</p>
<blockquote>
<p>判断队列是否为空。</p>
<p>参数列表：无</p>
<p>返回值类型：boolean</p>
</blockquote>
<p>（2）offer(Integer value)</p>
<blockquote>
<p>入队。</p>
<p>参数列表：integer value</p>
<p>返回值类型：boolean</p>
</blockquote>
<p>（3）poll()</p>
<blockquote>
<p>出队并返回值。</p>
<p>参数列表：无</p>
<p>返回值类型：int</p>
</blockquote>
<p>（4）peek()</p>
<blockquote>
<p>查看队首元素。</p>
<p>参数列表：无</p>
<p>返回值类型：int</p>
</blockquote>
<h3 id="java类Deque"><a href="#java类Deque" class="headerlink" title="java类Deque"></a>java类Deque</h3><p>1、创建一个双端队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Deque&lt;Integer&gt; deq = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>2、常用方法</p>
<p>（1）isEmpty()</p>
<blockquote>
<p>判断队列是否为空。</p>
<p>参数列表：无</p>
<p>返回值类型：boolean</p>
</blockquote>
<p>（2）offerFirst(integer value) 和 offerLast(integer value)</p>
<blockquote>
<p>从首端入队；从尾端入队</p>
<p>参数列表：int value</p>
<p>返回值类型：boolean</p>
</blockquote>
<p>（3）pollFirst() 和 pollLast()</p>
<blockquote>
<p>从首端出队并返回值；从尾端出队并返回值</p>
<p>参数列表：无</p>
<p>返回值类型：int</p>
</blockquote>
<p>（4）removeFirst()和removeLast()</p>
<blockquote>
<p>从首端删除元素并返回值；从尾端删除元素并返回值</p>
<p>参数列表：无</p>
<p>返回值类型：int</p>
</blockquote>
<p>​      与pollFirst() 和 pollLast()的功能没啥区别。</p>
<p>（5）peekFirst() 和 peekLast()</p>
<blockquote>
<p>查看首端元素；查看尾端元素</p>
<p>参数列表：无</p>
<p>返回值类型：int</p>
</blockquote>
<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>1、max_value()</p>
<blockquote>
<p>每次时间复杂度都是O(1)，直接返回双端队列的首端元素。</p>
</blockquote>
<p>2、push_back()</p>
<blockquote>
<p>均摊时间复杂度为O(1)（并不一定每次时间复杂度都是O(1)），例如 76543218 ，最后一次 push_back 操作是O(n)，其他每次push_back 操作都是O(1)，均摊时间复杂度为(O(1)×(n-1)+O(n))/n=O(1)。</p>
</blockquote>
<p>3、pop_front()</p>
<blockquote>
<p>每次时间复杂度都是O(1)，从普通队列里出一个元素，如果该元素恰好是最大值，双端队列的首端元素也出队，仍然是常数时间复杂度。</p>
</blockquote>
<p>小结：</p>
<blockquote>
<p>在时间复杂度为O(1)的情况下，找栈或队列的最大值或最小值，往往需要一个辅助的数据结构来实现，具体选用什么样的数据结构需要在做题过程中进行总结。</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机</category>
        <category>《剑指offer》（第2版）</category>
        <category>队列</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》（第2版）</tag>
        <tag>队列</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>59-I(简单)：滑动窗口的最大值</title>
    <url>/posts/701a824e.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>59-I：<a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">滑动窗口的最大值</a></p>
<blockquote>
<p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], 和 k = <span class="number">3</span></span><br><span class="line">输出: [<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[<span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>] -<span class="number">3</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span> [<span class="number">3</span>  -<span class="number">1</span>  -<span class="number">3</span>] <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span> [-<span class="number">1</span>  -<span class="number">3</span>  <span class="number">5</span>] <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span> [-<span class="number">3</span>  <span class="number">5</span>  <span class="number">3</span>] <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>  -<span class="number">3</span> [<span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>] <span class="number">7</span>       <span class="number">6</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>  -<span class="number">3</span>  <span class="number">5</span> [<span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>]      <span class="number">7</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>使用一个双端单调队列和一个数组来辅助。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">		 <span class="keyword">if</span>(nums.length==<span class="number">0</span>) &#123;<span class="comment">//数组为空</span></span><br><span class="line">			 <span class="keyword">return</span> nums;</span><br><span class="line">		 &#125;</span><br><span class="line">		 </span><br><span class="line">		 <span class="keyword">int</span>[] max = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length-k+<span class="number">1</span>];<span class="comment">//数组，辅助，存放滑动窗口的最大值</span></span><br><span class="line">		 <span class="keyword">int</span> max_index=<span class="number">0</span>;</span><br><span class="line">		 </span><br><span class="line">		 Deque&lt;Integer&gt; deq=<span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">//双端单调队列，辅助，找滑动窗口里的最大值</span></span><br><span class="line">		 		 </span><br><span class="line">		 <span class="comment">//第一个窗口里的元素入双端单调队列</span></span><br><span class="line">		 <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++) &#123;</span><br><span class="line">			 <span class="keyword">while</span>(!deq.isEmpty() &amp;&amp; deq.peekLast()&lt;nums[i]) &#123;</span><br><span class="line">				 deq.removeLast();</span><br><span class="line">			 &#125;</span><br><span class="line">			 deq.offerLast(nums[i]);</span><br><span class="line">		 &#125;</span><br><span class="line">		 </span><br><span class="line">		 <span class="comment">//双端单调队列的首元素存到数组max里</span></span><br><span class="line">		 max[max_index++] = deq.peekFirst();</span><br><span class="line">		 </span><br><span class="line">		 <span class="comment">//将窗口滑动</span></span><br><span class="line">		 <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;nums.length;i++) &#123;</span><br><span class="line">			 </span><br><span class="line">			 <span class="comment">//双端单调队列的首元素为过时数据(滑动窗口的前一个元素)，直接出队</span></span><br><span class="line">			 <span class="keyword">if</span>(deq.peekFirst()==nums[i-k]) &#123;</span><br><span class="line">				 deq.removeFirst();</span><br><span class="line">			 &#125;</span><br><span class="line">			 </span><br><span class="line">			 <span class="keyword">while</span>(!deq.isEmpty() &amp;&amp; deq.peekLast()&lt;nums[i]) &#123;</span><br><span class="line">				 deq.removeLast();</span><br><span class="line">			 &#125;</span><br><span class="line">			 deq.offerLast(nums[i]);</span><br><span class="line">			 </span><br><span class="line">			 max[max_index++] = deq.peekFirst();</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">	    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h2><p>&emsp;&emsp;窗口滑动的过程中，第一个窗口的元素入双端单调队列，比较特殊，需要入k个元素得到一个最大值；后面的其他窗口，都一样，每入1个元素得到一个最大值。</p>
<p>&emsp;&emsp;所以，第一个窗口的元素入双端单调队列，单独出一段代码。</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>《剑指offer》（第2版）</category>
        <category>队列</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》（第2版）</tag>
        <tag>简单</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>03(简单)：数组中重复的数字</title>
    <url>/posts/c0483027.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>03：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">数组中重复的数字</a></p>
<blockquote>
<p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line">输出：<span class="number">2</span> 或 <span class="number">3</span> </span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>使用一个HashSet来辅助。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//创建一个哈希表(空的)</span></span><br><span class="line">		HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//依次往哈希表里添数组中的元素</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x:nums) &#123;</span><br><span class="line">			<span class="keyword">if</span>(set.contains(x)) &#123;</span><br><span class="line">				<span class="keyword">return</span> x;</span><br><span class="line">			&#125;</span><br><span class="line">			set.add(x);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h2><h3 id="Java类HashSet"><a href="#Java类HashSet" class="headerlink" title="Java类HashSet"></a>Java类HashSet</h3><p>1、HashSet的特点</p>
<blockquote>
<p>由它创建的对象，是一个无序的且不允许出现重复元素的集合。</p>
</blockquote>
<p>2、创建一个哈希表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>3、常用方法</p>
<p>（1）contains(Integer x)</p>
<blockquote>
<p>判断哈希表里是否包含x</p>
<p>参数列表：Integer x</p>
<p>返回值类型：boolean</p>
</blockquote>
<p>（2）add(Integer x)</p>
<blockquote>
<p>往哈希表里添一个元素</p>
<p>参数列表：integer value</p>
<p>返回值类型：boolean</p>
</blockquote>
<h3 id="遍历数组的元素"><a href="#遍历数组的元素" class="headerlink" title="遍历数组的元素"></a>遍历数组的元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x:nums) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，x为数组nums中的元素。</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>《剑指offer》（第2版）</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》（第2版）</tag>
        <tag>简单</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>java：-source1.5中不支持diamond运算符(请使用-source7或更高版本以启用diamond运算符)</title>
    <url>/posts/af530ec4.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;往idea里导入一个现有的项目后，运行时报错。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote>
<p>java：-source1.5中不支持diamond运算符(请使用-source7或更高版本以启用diamond运算符)</p>
</blockquote>
<a id="more"></a>

<h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>&emsp;&emsp;该项目Modules中的Language level为1.5，版本较低，不支持diamond运算符(&lt;&gt;)。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>&emsp;&emsp;将该项目Modules中的Language level改为7或者更高的版本。</p>
<p>&emsp;&emsp;具体操作：</p>
<blockquote>
<p>File → Projuect structure → Modules → Sources → Language level</p>
<p>修改即可。</p>
</blockquote>
<h2 id="后续问题与解决方法"><a href="#后续问题与解决方法" class="headerlink" title="后续问题与解决方法"></a>后续问题与解决方法</h2><p>&emsp;&emsp;上述问题解决后，会出现以下问题：</p>
<blockquote>
<p>java：Compilation failed：internal java compiler error</p>
</blockquote>
<p>&emsp;&emsp;根据错误提示，可知，内部的java编译器出错。具体解决方法：</p>
<blockquote>
<p>File → Settings</p>
<p>搜索框里：Java Complier，进入</p>
<p>修改Module的Target bytecode version与Language level一致即可。</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机</category>
        <category>环境</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>29(简单)：顺时针打印矩阵</title>
    <url>/posts/d23265fa.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>29：<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">顺时针打印矩阵</a></p>
<blockquote>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
</blockquote>
<p>示例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>像剥洋葱一样，直到遍历结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">int</span> height = matrix.length;</span><br><span class="line">        <span class="comment">//matrix为空</span></span><br><span class="line">        <span class="keyword">if</span>(height==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> width = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//矩阵中未遍历的上下左右界限</span></span><br><span class="line">        <span class="keyword">int</span> top=<span class="number">0</span>,bottom=height-<span class="number">1</span>,left=<span class="number">0</span>,right=width-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[width*height];</span><br><span class="line">        <span class="keyword">int</span> arr_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++)&#123;</span><br><span class="line">                arr[arr_index++]=matrix[top][i];</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            <span class="keyword">if</span>(top&gt;bottom) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=top;i&lt;=bottom;i++)&#123;</span><br><span class="line">                arr[arr_index++]=matrix[i][right];</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">if</span>(right&lt;left) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=right;i&gt;=left;i--)&#123;</span><br><span class="line">                arr[arr_index++]=matrix[bottom][i];</span><br><span class="line">            &#125;</span><br><span class="line">            bottom--;</span><br><span class="line">            <span class="keyword">if</span>(bottom&lt;top) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=bottom;i&gt;=top;i--)&#123;</span><br><span class="line">                arr[arr_index++]=matrix[i][left];</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(left&gt;right) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h2><h3 id="二维数组的长度"><a href="#二维数组的长度" class="headerlink" title="二维数组的长度"></a>二维数组的长度</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length = arr.length;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;length = &quot;</span> + length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">length = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>二维数组可认为是由一维数组组成。</p>
<p>很显然，二维数组的长度为一维数组的个数。</p>
<h3 id="一个矩阵的行数和列数"><a href="#一个矩阵的行数和列数" class="headerlink" title="一个矩阵的行数和列数"></a>一个矩阵的行数和列数</h3><p>使用二维数组来表示一个矩阵。</p>
<blockquote>
<p>矩阵的行数  =  二维数组的长度</p>
<p>矩阵的列数  =  一维数组的长度</p>
</blockquote>
<h3 id="直接返回一维空数组"><a href="#直接返回一维空数组" class="headerlink" title="直接返回一维空数组"></a>直接返回一维空数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>《剑指offer》（第2版）</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》（第2版）</tag>
        <tag>简单</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>53-I(简单)：在排序数组中查找数字I</title>
    <url>/posts/218fb600.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>53-I：<a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">在排序数组中查找数字I</a></p>
<blockquote>
<p>统计一个数字在排序数组中出现的次数。</p>
</blockquote>
<p>示例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>], target = <span class="number">8</span></span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>], target = <span class="number">6</span></span><br><span class="line">输出: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="方案1：暴力破解"><a href="#方案1：暴力破解" class="headerlink" title="方案1：暴力破解"></a>方案1：暴力破解</h3><p>直接遍历数组，数组元素=target，次数+1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">0</span>;<span class="comment">//次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==target)&#123;</span><br><span class="line">                n++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方案2：算法优化"><a href="#方案2：算法优化" class="headerlink" title="方案2：算法优化"></a>方案2：算法优化</h3><blockquote>
<p>采用二分法。</p>
</blockquote>
<p>1、值为target的元素，在数组nums中，形成一个窗口。要想统计值为target元素的个数，只需找到窗口的右侧首元素索引right和左侧首元素索引left即可。值为target元素的个数 = right-(left+1)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化指针</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环二分,寻找窗口的右侧首元素索引</span></span><br><span class="line">        <span class="keyword">while</span> (i&lt;=j)&#123;</span><br><span class="line">            <span class="keyword">int</span> m=(i+j)/<span class="number">2</span>;<span class="comment">//默认向下取整</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[m]&lt;=target)&#123;</span><br><span class="line">                i=m+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                j=m-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//无值为target的元素</span></span><br><span class="line">        <span class="keyword">if</span>(j&gt;=<span class="number">0</span> &amp;&amp; nums[j]!=target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重置指针</span></span><br><span class="line">        i=<span class="number">0</span>;j=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//循环二分，寻找窗口的左侧首元素索引</span></span><br><span class="line">        <span class="keyword">while</span> (i&lt;=j)&#123;</span><br><span class="line">            <span class="keyword">int</span> m=(i+j)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[m]&lt;target)&#123;</span><br><span class="line">                i=m+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                j=m-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right-(left+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、换种思维方式，值为target的元素个数 = target窗口右侧首元素索引 - (target-1)窗口右侧首元素索引</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right(nums,target)-right(nums,target-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化指针</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环二分,寻找窗口的右侧首元素</span></span><br><span class="line">        <span class="keyword">while</span> (i&lt;=j)&#123;</span><br><span class="line">            <span class="keyword">int</span> m=(i+j)/<span class="number">2</span>;<span class="comment">//默认向下取整</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[m]&lt;=target)&#123;</span><br><span class="line">                i=m+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                j=m-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h2><h3 id="排序数组中的查找问题"><a href="#排序数组中的查找问题" class="headerlink" title="排序数组中的查找问题"></a>排序数组中的查找问题</h3><blockquote>
<p>首先想到用二分法来解决。</p>
</blockquote>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>方案1：</p>
<blockquote>
<p>时间复杂度：O(n)，遍历为线性级别复杂度。</p>
<p>空间复杂度：O(1)，几个变量使用常数大小的额外空间。</p>
</blockquote>
<p>方案2：</p>
<blockquote>
<p>时间复杂度：O(logn)，二分法为对数级别复杂度。</p>
<p>空间复杂度：O(1)，几个变量使用常数大小的额外空间。</p>
</blockquote>
<p>很显然，二分法更有优势。</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>《剑指offer》（第2版）</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》（第2版）</tag>
        <tag>简单</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>53-II(简单)：0~n-1中缺失的数字</title>
    <url>/posts/3af126c2.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>53-II：<a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">0~n-1中缺失的数字</a></p>
<blockquote>
<p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
</blockquote>
<p>实例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>实例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line">输出: <span class="number">8</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="方案1：暴力求解"><a href="#方案1：暴力求解" class="headerlink" title="方案1：暴力求解"></a>方案1：暴力求解</h3><p>缺失的数字分为两种情况：</p>
<blockquote>
<p>第一种情况：缺失的是最后一个数字，即n-1，直接return nums.length。</p>
<p>第二种情况：缺失的是除最后一个数字之外的任何其他数字，这时它是数组中第一个元素值≠其对应的索引的数字。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=i)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方案2：算法优化"><a href="#方案2：算法优化" class="headerlink" title="方案2：算法优化"></a>方案2：算法优化</h3><p>采用二分法。</p>
<blockquote>
<p>将数组分为两部分：左子数组和右子数组。</p>
<p>左子数组：元素值 = 索引</p>
<p>右子数组：首元素值 ≠ 索引</p>
<p>此时，缺失的数字即为右子数组的首元素。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环二分</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            <span class="keyword">int</span> m=(i+j)/<span class="number">2</span>;<span class="comment">//默认向下取整</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[m]==m)&#123;</span><br><span class="line">                i=m+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                j=m-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;<span class="comment">//返回右子数组的首元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h2><h3 id="排序数组中的查找问题"><a href="#排序数组中的查找问题" class="headerlink" title="排序数组中的查找问题"></a>排序数组中的查找问题</h3><blockquote>
<p>首先想到用二分法来解决。</p>
</blockquote>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>方案1：</p>
<blockquote>
<p>时间复杂度：O(n)，遍历为线性级复杂度。</p>
<p>空间复杂度：O(1)，几个变量使用常数大小的额外空间。</p>
</blockquote>
<p>方案2：</p>
<blockquote>
<p>时间复杂度：O(logn)，二分法为对数级复杂度。</p>
<p>空间复杂度：O(1)，几个变量使用常数大小的额外空间。</p>
</blockquote>
<p>很显然，二分法更有优势。</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>《剑指offer》（第2版）</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>《剑指offer》（第2版）</tag>
        <tag>简单</tag>
        <tag>数组</tag>
      </tags>
  </entry>
</search>
